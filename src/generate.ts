import { writeFileSync, existsSync, mkdirSync, readFileSync } from 'fs';
import path from 'path';
import { sync as globSync } from 'glob';

function generateEthers(contract: string, outputDir: string) {
    const template = `/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */

import { ContractFactory } from 'ethers';
import { abi, bytecode } from '../abi/${contract}.json';

export default new ContractFactory(abi, bytecode);`;

    writeFileSync(path.resolve(outputDir, `${contract}.ts`), template);
}

function generateTruffle(contract: string, outputDir: string) {
    const template = `/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */

import { ${contract}Contract as ContractInterface } from '../types/truffle/${contract}';
import Artifact from '../abi/${contract}.json';

const Contract = require('@truffle/contract');
export default Contract(Artifact) as ContractInterface;`;

    writeFileSync(path.resolve(outputDir, `${contract}.ts`), template);
}

function generateWeb3(contract: string, outputDir: string) {
    const template = `/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */

import Web3 from 'web3';
import { ${contract} as ContractInterface } from '../types/web3/${contract}';
import { abi, bytecode } from '../abi/${contract}.json';

const ContractFactory = (web3: Web3, address: string | undefined) =>
    new web3.eth.Contract(abi as any, address, {
        data: bytecode,
        from: web3.eth.defaultAccount ?? undefined,
    }) as unknown as ContractInterface;
export default ContractFactory;`;

    writeFileSync(path.resolve(outputDir, `${contract}.ts`), template);
}

function generateIndex(
    contracts: string[],
    { ethers, truffle, web3 }: { ethers: string; truffle: string; web3: string },
) {
    let indexFile = `/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
`;
    contracts.forEach((contract) => {
        indexFile = `${indexFile}\nimport ${contract} from './${contract}'`;
    });

    indexFile = `${indexFile}\nexport { ${contracts} };`;
    writeFileSync(path.resolve(ethers, 'index.ts'), indexFile);
    writeFileSync(path.resolve(truffle, 'index.ts'), indexFile);
    writeFileSync(path.resolve(web3, 'index.ts'), indexFile);
}

function generateAbiIndex(contracts: string[], abi: string) {
    let indexFile = `/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
`;
    contracts.forEach((contract) => {
        indexFile = `${indexFile}\nimport ${contract} from './${contract}.json'`;
    });

    indexFile = `${indexFile}\nexport { ${contracts} };`;
    writeFileSync(path.resolve(abi, 'index.ts'), indexFile);
}

function generate(contracts: string[], { ethers, truffle, web3 }: { ethers: string; truffle: string; web3: string }) {
    contracts.forEach((contract) => {
        generateEthers(contract, ethers);
        generateTruffle(contract, truffle);
        generateWeb3(contract, web3);
    });
    generateIndex(contracts, { ethers, truffle, web3 });
}

function main() {
    //Abi index.ts
    //Do NOT index ABIs generated from imported libraries
    const contractsSolidityNames = globSync('src/solidity/**/*.sol').map((x) => path.basename(x).replace('.sol', ''));
    const contractsAbiNames = globSync('src/abi/**/*.json').map((x) => path.basename(x).replace('.json', ''));
    const contractNamesSet = new Set(contractsSolidityNames);
    const indexedAbis = contractsAbiNames.filter((abi) => {
        return contractNamesSet.has(abi);
    });
    generateAbiIndex(indexedAbis, 'src/abi');

    //Generate factories
    //Deployable contracts only
    const deployableAbis = indexedAbis.filter((x) => {
        const { abi, bytecode } = JSON.parse(readFileSync(`src/abi/${x}.json`, 'utf-8'));
        return abi && abi.length > 0 && bytecode && bytecode.length > 2; //Bytecode != 0x
    });
    const outputDir = { ethers: 'src/ethers', truffle: 'src/truffle', web3: 'src/web3' };
    if (!existsSync(outputDir.ethers)) mkdirSync(outputDir.ethers);
    if (!existsSync(outputDir.truffle)) mkdirSync(outputDir.truffle);
    if (!existsSync(outputDir.web3)) mkdirSync(outputDir.web3);

    generate(deployableAbis, outputDir);
}

if (typeof require !== 'undefined' && require.main === module) {
    main();
}
